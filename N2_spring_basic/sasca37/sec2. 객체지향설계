## 객체 지향 프로그래밍

-   객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러  
    개의 독립된 단위, 즉 "객체"들의 모임으로 파악하고자 하는 것이다. 각각의 객체는 메시지  
    를 주고받고, 데이터를 처리할 수 있다.
-   객체 지향 프로그래밍은 프로그램을 유연하고 변경이 용이하게 만들기 때문에 대규모 소프  
    트웨어 개발에 많이 사용된다

## 객체 지향 특징

-   추상화 : 실세계와 객체 지향을 1대1로 매칭하지 않는다. 역할과 구현으로 세상을 구분  
    역할과 구현 분리 장점 (클라이언트는 대상의 역할(인터페이스)만 알면 되므로 유연해지며 변경이 편리해진다.)

-   ![sec1캡쳐2](https://user-images.githubusercontent.com/81945553/126928875-0ef3b872-1205-4cdc-ae0f-b015cb8ae12f.png)
-   캡슐화 : 관련이 있는 변수와 함수를 하나의 클래스로 묶고 외부에서 쉽게 접근하지 못하도록 은닉
-   상속 : 자식이 부모로부터 물려받는 것
-   다형성 (가장 중요)
-   ![sec1캡처3](https://user-images.githubusercontent.com/81945553/126929475-ebb1b58c-2be2-43bd-a999-2de35ec9a9e4.png)
    
-   인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경 가능
-   클라이언트를 변경하지 않고, 서버의 구현 기능을 변경할 수 있다.
-   스프링에선 이 다형성을 사용하기 쉽게 IoC, DI를 지원해준다.

## 객체지향 설계 5원칙 (SOLID)

![sec1캡처4](https://user-images.githubusercontent.com/81945553/126929762-f011cf24-47a1-4bef-82b7-5e03383e805c.png)

-   SRP : 한 클래스는 하나의 책임만 가져야 한다.  
    ※ 상황에 따라 다를 수 있으므로 변경이 있을 때 파급 효과가 적으면 SRP를 잘 준수 했다고 볼 수 있다.
-   OCP : 확장에는 열려 있으나 변경에는 닫혀 있어야한다.  
    인터페이스를 구현한 새로운 클래스를 추가하여 기능을 구현 (역할과 구현의 분리)다형성을 사용했지만 클라이언트의 코드는 변경해야한다. 연관관계 설정을 통한 별도의 조립이 필요하다.
-   `private Repository repository = new MRepository(); //기존 , Repository : 인터페이스 , MRepository : 클래스 private Repository repository = new JRepository(); //변경`
-   LSP : 객체는 정확성을 깨뜨리지 않으면서 하위타입의 인스턴스로 바꿀 수 있어야한다.  
    EX) 자동차 전진 인터페이스 구현 시 앞으로만 가능 기능만 있어야한다. 뒤로 가는 구현 발생시 LSP 위반
-   ISP : 특정 클라이언트를 위한 여러 인터페이스가 범용 인터페이스 하나 보다 낫다. (대체 가능성 높아짐)  
    EX) 자동차 인터페이스 -> 운전자, 정비 인터페이스로 분리 사용자 클라이어트 -> 운전자, 정비사 클라이언트로 분리
-   DIP : 의존관계 역전 원칙구현 클래스를 직접 선택 했으므로 DIP 위반 ( 즉, 다형성만으로 OCP, DIP 지킬 수 없다.)
-   `private Repository repository = new MRepository();`

## Configuration

```
- 기존의 코드는 Impl에서 직접 객체를 생성하여 구현체에 의존을 하게 되어 DIP를 위반했었다.
- 구현체에 의존하지않고 실행에만 집중해야한다. (구현체로 무엇이 와도 실행에 지장이 없어야 한다.)
- 이를 해결하기 위해선 필요한 객체를 한곳에 모아서 관리해주는 컨테이너가 필요하다.
```

```
public class AppConfig {

    public MemberService memberService() {
        return new MemberServiceImpl(memberRepository());
    }

    public MemberRepository memberRepository() {
        return new MemoryMemberRepository();
    }

    public OrderService orderService(){
        return new OrderServiceImpl(memberRepository(), discountPolicy());
    }

    public DiscountPolicy discountPolicy() {
        return new RateDiscountPolicy();
    }
}
```

-   객체를 관리해주는 AppConfig 클래스를 생성

```
 private final MemberRepository memberRepository;
    private final DiscountPolicy discountPolicy;
    // 기존 : private final DiscountPolicy discountPolicy = new RateDiscountPolicy();
    public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
        this.memberRepository = memberRepository;
        this.discountPolicy = discountPolicy;
    }
```

-   기존의 new 연산자를 통한 인스턴스 생성이 아닌, 생성자 주입을 통해 구현체를 주입 받는다.
-   impl 입장에선 discountPolicy의 인터페이스의 어떤 구현체가 올지 모른다.
-   DIP를 지킬 수 있게 되었으며, 자연스럽게 SRP, OCP도 지킬 수 있게 된다.
